import numpy as np
import pandas as pd


def get_independent_joint_probability_matrix(syllable_series1, syllable_series2, output_index=None):
    """
    Get the independent joint probability matrix of two syllable series. The independent joint probability matrix is the
    matrix where the (i, j)th entry is the product of the probability of the ith syllable in the first series and the
    probability of the jth syllable in the second series.

    :param syllable_series1: A series of syllables
    :type syllable_series1: pd.Series
    :param syllable_series2: A series of syllables
    :type syllable_series2: pd.Series
    :param output_index: Index to use for the output matrix. If None, the index is the union of the unique syllables in
    syllable_series1 and syllable_series2
    :type output_index: pd.Index or None
    :return: Independent joint probability matrix
    :rtype: pd.DataFrame
    """
    frequencies1 = syllable_series1.value_counts(normalize=True).sort_index()
    frequencies2 = syllable_series2.value_counts(normalize=True).sort_index()

    if output_index is None:
        output_index = frequencies1.index.union(frequencies2.index).sort_values()
    frequencies1 = frequencies1.reindex(output_index, fill_value=0)
    frequencies2 = frequencies2.reindex(output_index, fill_value=0)

    merged_frequencies = pd.merge(frequencies1, frequencies2, how="cross").set_index(
        pd.MultiIndex.from_product([frequencies1.index, frequencies2.index],
                                   names=[syllable_series1.name, syllable_series2.name])
    )
    merged_frequencies.columns = ["frequency1", "frequency2"]
    merged_frequencies["joint_frequency"] = merged_frequencies["frequency1"] * merged_frequencies["frequency2"]
    joint_probability_matrix = merged_frequencies["joint_frequency"].unstack().fillna(0)
    joint_probability_matrix /= joint_probability_matrix.sum().sum()
    return joint_probability_matrix


def get_lag_occurrence_matrix_dict(syllable_series1, syllable_series2, max_lag=5, output_index=None):
    """
    Get a dictionary containing the lag occurrence matrices of two syllable series. Every key in the dictionary is a lag
    value in the range (0, max_lag + 1). The lag occurrence matrix is the matrix where the (i, j)th entry is the
    probability of the ith syllable in the first series occurring with the jth syllable in the second series with a lag
    of the key.

    :param syllable_series1: A series of syllables
    :type syllable_series1: pd.Series
    :param syllable_series2: A series of syllables
    :type syllable_series2: pd.Series
    :param max_lag: Maximum lag value. Must be a non-negative integer
    :type max_lag: int
    :param output_index: Index to use for the output matrix. If None, the index is the union of the unique syllables in
    syllable_series1 and syllable_series2
    :type output_index: pd.Index or None
    :return: Dictionary containing the lag occurrence matrices
    :rtype: dict
    """

    lag_occurrence_matrix_dict = {}

    if syllable_series1.name == syllable_series2.name:
        syllable_series1 = syllable_series1.copy().rename("syllable_series1")
        syllable_series2 = syllable_series2.copy().rename("syllable_series2")

    if output_index is None:
        output_index = pd.Index(syllable_series1.unique()).union(syllable_series2.unique()).sort_values()

    for lag in range(max_lag + 1):
        lag_occurrence_matrix = pd.concat([syllable_series1, syllable_series2.shift(lag)], axis=1).dropna(
            how="any").value_counts(normalize=True).unstack().fillna(0)
        lag_occurrence_matrix = lag_occurrence_matrix.reindex(index=output_index, columns=output_index, fill_value=0)
        lag_occurrence_matrix_dict[lag] = lag_occurrence_matrix / lag_occurrence_matrix.sum().sum()

    return lag_occurrence_matrix_dict


def generate_random_syll_series(target_length, syllable_bout_lengths, syllable_probabilities=None,
                                syllable_transition_probabilities=None, random_state=None):
    """
    Generate a random syllable sequence based on the probabilities of each syllable and the bout lengths of each
    syllable. The sequence is generated by randomly selecting a syllable based on the probabilities, and then randomly
    selecting a bout length based on the bout lengths of the selected syllable. This process is repeated until the
    sequence reaches the target length. A list of syllables is returned.

    :param target_length: The length of the target sequence
    :type target_length: int
    :param syllable_probabilities: A series containing the probabilities of each syllable
    :type syllable_probabilities: pd.Series
    :param syllable_bout_lengths: A Series with a MultiIndex containing the bout lengths of each syllable. First index
    is the syllable, and the second index is an arbitrary identifier with the bout length as the value.
    :type syllable_bout_lengths: pd.Series
    :param syllable_transition_probabilities: A DataFrame containing the transition probabilities between syllables. The
    index and columns are the syllables, and the values are the probabilities of transitioning from the row syllable to
    the column syllable.
    :type syllable_transition_probabilities: pd.DataFrame
    :param random_state: An optional random state to be passed to avoid creating a new random state every time.
    :type random_state: np.random.Generator or None
    :return: Random syllable sequence
    :rtype: list
    """
    if random_state is None:
        random_state = np.random.default_rng()

    if syllable_probabilities is None:
        syllable_probabilities = syllable_bout_lengths.index.get_level_values(0).value_counts(normalize=True)
    syllable_probabilities = syllable_probabilities / syllable_probabilities.sum()

    if syllable_transition_probabilities is None:
        syllable_transition_probabilities = pd.DataFrame(index=syllable_probabilities.index,
                                                         columns=syllable_probabilities.index)
        syllable_transition_probabilities[:] = syllable_probabilities

    random_syllable_sequence = []
    previous_syllable = random_state.choice(a=syllable_probabilities.index, size=1, p=syllable_probabilities.values)[0]
    while len(random_syllable_sequence) < target_length:
        random_syllable = random_state.choice(a=syllable_transition_probabilities.columns, size=1,
                                              p=syllable_transition_probabilities.loc[previous_syllable].values)[0]
        random_bout_length = random_state.choice(a=syllable_bout_lengths.loc[random_syllable].values, size=1)[0]
        random_syllable_sequence += [random_syllable] * random_bout_length
        previous_syllable = random_syllable

    return random_syllable_sequence[:target_length]
